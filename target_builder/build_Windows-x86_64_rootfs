#! /usr/bin/bash
set -o pipefail

# Any Error, do exit !!
set -e

readonly OUTPUT_DIR="${WORKDIR}/output/"
readonly LOG_DIR="${OUTPUT_DIR}/logs/"

readonly TARGET_PLT="$(echo -n "${TARGET}" | cut -d '-' -f1)"
readonly TARGET_ARCH="$(echo -n "${TARGET}" | cut -d '-' -f2)"

if [[ "${TARGET_ARCH}" == arm64 ]]; then
	CROSS_COMPILE="aarch64-linux-gnu-"
fi

if [[ "${TARGET_ARCH}" == x86_64 ]]; then
	CROSS_COMPILE="x86_64-linux-gnu-"
fi

if [[ -f "/usr/bin/${CROSS_COMPILE}strip" ]]; then
	STRIPER="/usr/bin/${CROSS_COMPILE}strip"
else
	echo "/usr/bin/$CROSS_COMPILE-strip" not find !!
	exit 100
fi

MAKE_JOBS="$(nproc)"

build_busybox_static() {
	echo "Enter function: ${FUNCNAME[0]} "

	cd "${WORKDIR}"
	local busybox_src="${OUTPUT_DIR}/busybox"
	local clean_build=false
	local commit_id="1a64f6a20aaf6ea4dbba68bbfa8cc1ab7e5c57c4" # busybox v1.36.1
	local repo="https://git.busybox.net/busybox"
	local busybox_config="${WORKDIR}/configs/x86_64/busybox/busybox-config"

	if [[ -d "${busybox_src}" ]]; then
		echo ""
	else
		git clone "${repo}" "${busybox_src}"
	fi

	cd "${busybox_src}"

	cp "${busybox_config}" "${busybox_src}/.config"

	if [[ -z "${CROSS_COMPILE}" ]]; then
		echo "var CROSS_COMPILE not set, stop !"
		exit 100
	fi

	if [[ "${clean_build}" == "true" ]]; then
		ARCH="${TARGET_ARCH}" CROSS_COMPILE=${CROSS_COMPILE} make -j"$MAKE_JOBS" -C "${busybox_src}" clean
	fi

	ARCH="${TARGET_ARCH}" CROSS_COMPILE=${CROSS_COMPILE} make -j "$MAKE_JOBS" -C "${busybox_src}"

	ARCH="${TARGET_ARCH}" CROSS_COMPILE=${CROSS_COMPILE} make -j "$MAKE_JOBS" -C "${busybox_src}" install
	BUSYBOX_BIN="${busybox_src}/_install/bin/busybox"
	echo "Endof function: ${FUNCNAME[0]} "
}

pull_ubuntu_rootfs() {
	echo "Enter function: ${FUNCNAME[0]} "
	cd "${WORKDIR}"

	if [[ "${TARGET_ARCH}" == x86_64 ]]; then
		UBT_ARCH="amd64"
	fi

	local cdimage="ubuntu-base-24.04-base-${UBT_ARCH}"
	local stufix="tar.gz"
	local ubunturootfs="${OUTPUT_DIR}/${cdimage}"
	local url="https://cdimage.ubuntu.com/ubuntu-base/releases/24.04/release/${cdimage}.${stufix}"
	wget -c "${url}" --output-document "${OUTPUT_DIR}/${cdimage}.${stufix}"

	if [[ -d "${ubunturootfs}" ]]; then
		echo "Skip extract ${OUTPUT_DIR}/${cdimage}.${stufix}"
	else
		mkdir -p "${ubunturootfs}"
		tar -xvf "${OUTPUT_DIR}/${cdimage}.${stufix}" -C "${ubunturootfs}"
	fi

	UBT_ROOTFS="${ubunturootfs}"

	proot --root-id -R "${UBT_ROOTFS}" apt -y update
	proot --root-id -R "${UBT_ROOTFS}" apt -y install apt-utils iptables grep tar file
	LDDRET=$(proot --root-id -R "${UBT_ROOTFS}" \
		ldd /usr/sbin/iptables | grep -v linux-vdso |cut -d '>' -f2 | cut -d '(' -f1
	)
	IPTABLES_LIBS=$(proot --root-id -R "${UBT_ROOTFS}" \
		file -L $(dpkg -L iptables) | grep ELF| cut -d ':' -f1
	)

	echo "Endof function: ${FUNCNAME[0]} "
}

build_podman() {
	echo "Enter function: ${FUNCNAME[0]} "
	local podman_src="${OUTPUT_DIR}/podman_src"
	local repo="https://github.com/containers/podman"
	local commit_id="bda6eb03dcbcf12a5b7ae004c1240e38dd056d24" # podman v5.1.1

	if [[ -d "${podman_src}" ]]; then
		echo ""
	else

		git clone "${repo}" "${podman_src}"
	fi

	cd "${podman_src}"

	git checkout ${commit_id}
	make podman podman-remote

	if [[ -f bin/podman ]] && [[ -f bin/podman-remote ]]; then
		PODMAN_BIN="${podman_src}/bin/podman"
		PODMAN_REMOTE_BIN="${podman_src}/bin/podman-remote"
		${STRIPER} --strip-unneeded "${PODMAN_BIN}"
		${STRIPER} --strip-unneeded "${PODMAN_REMOTE_BIN}"
	else
		exit 100
	fi

	PODMAN_LIBS=$(ldd ${podman_src}/bin/podman | grep -v linux-vdso |cut -d '>' -f2 | cut -d '(' -f1)

	echo "Endof function: ${FUNCNAME[0]} "

}

build_conmon(){
	wget -c https://github.com/containers/conmon/releases/download/v2.1.12/conmon.amd64 --output-document "${OUTPUT_DIR}/conmon.amd64"
	CONMON="${OUTPUT_DIR}/conmon.amd64"
}

make_netavark() {
	echo "Enter function: ${FUNCNAME[0]} "
	local netavark_src="${OUTPUT_DIR}/netavark_src"
	local repo="https://github.com/containers/netavark"
	local commit_id="ab4f101a39b687c01e2df578162c2fa16a881c1b" # netavark v1.11.0

	if [[ -d "${netavark_src}" ]]; then
		echo ""
	else
		git clone "${repo}" "${netavark_src}"
	fi

	cd "${netavark_src}"
	git checkout "${commit_id}"
	make -j "${MAKE_JOBS}"
	if [[ -f "${netavark_src}/bin/netavark" ]]; then
		NETVAVRK_BIN="${netavark_src}/bin/netavark"
		${STRIPER} --strip-unneeded "${NETVAVRK_BIN}"
	else
		echo "${netavark_src}/bin/netavark NOT FIND"
		exit 100
	fi
	echo "Endof function: ${FUNCNAME[0]} "
}

make_wsl_rootfs() {

	cd "${WORKDIR}"
	echo "Enter function: ${FUNCNAME[0]} "
	local ovmrootfs_version="v1.0"
	local fakeroot="${OUTPUT_DIR}/ovmrootfs_fakeroot"                                  # Absolute path !
	local ovmrootfs="${fakeroot}/opt/ovmcorefilesystem/ovmrootfs_${ovmrootfs_version}" # Absolute path !

	rm -rf "${fakeroot}"

	mkdir -p "${ovmrootfs}/usr/lib/x86_64-linux-gnu/xtables"
	mkdir -p "${ovmrootfs}/usr/lib/wsl/drivers"
	mkdir -p "${ovmrootfs}/mnt/wslg/distro"
	mkdir -p "${ovmrootfs}/usr/lib/modules"
	mkdir -p "${ovmrootfs}/usr/lib/wsl/lib"
	mkdir -p "${ovmrootfs}/mnt/wslg/doc"
	mkdir -p "${ovmrootfs}/usr/lib64"
	mkdir -p "${ovmrootfs}/usr/bin"
	mkdir -p "${ovmrootfs}/etc"
	mkdir -p "${ovmrootfs}/home"
	mkdir -p "${ovmrootfs}/root"

	cp "${BUSYBOX_BIN}" "${ovmrootfs}/usr/bin"
	cd "${ovmrootfs}/usr/bin"
	echo "Install Busybox into ${ovmrootfs}"
	./busybox --install ./

	cd "${ovmrootfs}"
	ln -s usr/bin bin
	ln -s usr/lib lib
	ln -s usr/lib64 lib64

	echo "Install podman/netavark/conmon into ${ovmrootfs}"
	if [[ -f "${PODMAN_BIN}" ]] && [[ -f ${NETVAVRK_BIN} ]] && [[ -f ${CONMON} ]]; then
		mkdir -p "${ovmrootfs}/usr/libexec/podman/"
		cp -rf "${CONMON}" "${ovmrootfs}/usr/libexec/podman/conmon"
		chmod +x "${ovmrootfs}/usr/libexec/podman/conmon"
		cp "${PODMAN_BIN}" "${ovmrootfs}/usr/bin"
		cp "${NETVAVRK_BIN}" "${ovmrootfs}/usr/bin"
	else
		echo "Copy podman and netvavrk into wslrootfs failed !"
		exit 100
	fi

	{
		echo "We are in $(pwd)"
		echo "Create soft-link : opt/ovmcorefilesystem/ovmrootfs_${ovmrootfs_version} => ovmrootfs_current"
		cd "${fakeroot}"
		ln -sf -r "opt/ovmcorefilesystem/ovmrootfs_${ovmrootfs_version}" "ovmrootfs_current"

		dirs=$(busybox ls "ovmrootfs_current/")

		for d in ${dirs}; do
			echo ln -sf "ovmrootfs_current/${d}" ./"${d}"
			ln -sf "ovmrootfs_current/${d}" ./"${d}"
		done
	}

	touch /tmp/empty
	tar -cvf  /tmp/iptables.tar /tmp/empty

	for line in $IPTABLES_LIBS;do
		cd ${UBT_ROOTFS}
		tar --dereference -rvf /tmp/iptables.tar ${line} 2>/dev/null
	done
	for line in $LDDRET;do
		 cd ${UBT_ROOTFS}
		tar --dereference -rvf /tmp/iptables.tar ${line} 2>/dev/null
	done
	for line in ${PODMAN_LIBS};do
		tar --dereference -rvf /tmp/iptables.tar ${line} 2>/dev/null
	done
	cd ${SCRIPT_PATH}

	cd ${ovmrootfs}
	tar -xvf /tmp/iptables.tar -C ./

	cp -r ${UBT_ROOTFS}/etc/ld.so* "${ovmrootfs}/etc/"

	OVMCORE_FS="${ovmrootfs}"   # Absolute path !
	OVMCORE_OTAFS="${fakeroot}" # Absolute path !

	cd ${ovmrootfs}
	tar -Jcvf "${OUTPUT_DIR}/ovmrootfs.tar.xz" $(ls .)
	
	cd ${fakeroot}
	tar -Jcvf "${OUTPUT_DIR}/ovmrootfs_ota.tar.xz" $(ls .)

	echo "Endof function: ${FUNCNAME[0]} "
}

main() {
	# CALLER_ID make sure script called from make, not by others.
	if [[ "${CALLER_ID}" = "d9b59105e7569a37713aeadb493ca01a3779747f" ]]; then
		cd "$WORKDIR"
		build_busybox_static
		pull_ubuntu_rootfs
		build_podman
		make_netavark
		build_conmon
		make_wsl_rootfs

		echo '================================='
		echo OVMCORE_ROOTFS="${OVMCORE_FS}"
		echo OVMCORE_ROOTFS_ARCHIVE="${OUTPUT_DIR}/ovmrootfs.tar.xz"
		echo OVMCORE_OTAFS="${OVMCORE_OTAFS}"
		echo OVMCORE_OTAFS_ARCHIVE="${OUTPUT_DIR}/ovmrootfs_ota.tar.xz"
		echo BUSYBOX_BIN="${BUSYBOX_BIN}"
		echo PODMAN="${PODMAN_BIN}"
		echo PODMAN_REMOTE_BIN="${PODMAN_REMOTE_BIN}"
		echo '================================='
	else
		exit 1
	fi
}

main
